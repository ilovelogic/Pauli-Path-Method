#!pip install import-ipynb
import unittest
from typing import List, Tuple, DefaultDict
from collections import defaultdict
from circuit_sim import CircuitSim
from Brute_Force_RCS import circuit_utils
from prob_dist import ProbDist
from qiskit import circuit
from itertools import product
from Brute_Force_RCS.evaluation_utils import total_variation_distance, calculate_true_distribution, compute_xeb
from Brute_Force_RCS.circuit_utils import  complete_distribution, generate_emp_distribution
import math
import numpy as np
import warnings
import time
import os
import pdb
import matplotlib.pyplot as plt

from qiskit import QuantumCircuit 
        
class TestEverything(unittest.TestCase):
  @classmethod
  def setUpClass(self):   
    return

  
  def generatePauliPathDistribution(self, numQubits, depth, noiseRate, truncationParam):
    # if no truncation param is given, it defaults to no truncation
    if truncationParam == None:
      truncation = (depth+1)*numQubits
    else:
       truncation = truncationParam

    C = circuit_utils.random_circuit(numQubits, depth)
    warnings.filterwarnings("ignore", category=DeprecationWarning)

    gates = circuit_utils.extract_gates_info(C)
    gate_pos = []

    #endian order indexing
    for i in range(len(gates)):
      layer_num = gates[i][2]
      if layer_num+1 > len(gate_pos):
        gate_pos.append([])
      a, b = gates[i][1]
      gate_pos[layer_num].append((numQubits - a - 1, numQubits - b - 1))

    # Generate pauli circuit with input numqubits, depth, truncation, noise, 
    # and a random circuit generated by random_circuit 
    circuit = CircuitSim(numQubits, truncation, gate_pos)
    prob_dist = ProbDist(circuit, gates, numQubits, depth, C, noiseRate)
    return prob_dist.probs

#VARYING TRUNCATION-------------------------------------------------------------
#     MEASURE TIME--------------------------------------------------------------

  def measure_time_varying_truncation(
    self,
    numQubits: int,
    depth: int,
    noise: float,
    trunc_start: int, # should be greater than or equal to
    trunc_end: int,
    trunc_step: int,
    output_dir: str = "."
):
    filename = f"MeasuringTimeVaryingTruncation{numQubits}Qubits_{depth}Depth_{noise}Noise"
    filepath = os.path.join(output_dir, filename)

    with open(filepath, "w") as f:
        f.write("truncation,average_time_seconds\n")

        for trunc in range(trunc_start, trunc_end + 1, trunc_step):
            times = []
            print(trunc)
            for _ in range(5):
                start = time.time()
                _ = self.generatePauliPathDistribution(numQubits, depth, noise, trunc)
                end = time.time()
                times.append(end - start)
            avg_time = sum(times) / len(times)
            f.write(f"{trunc},{avg_time:.6f}\n")  
    
  def plot_time_varying_truncation(
      self,
      numQubits: int,
      depth: int,
      noise: float,
      trunc_start: int,
      trunc_end: int,
      trunc_step: int,
      output_dir: str = "."
  ) -> None:
      filename = f"MeasuringTimeVaryingTruncation{numQubits}Qubits_{depth}Depth_{noise}Noise"
      filepath = os.path.join(output_dir, filename)

      if not os.path.exists(filepath):
          raise FileNotFoundError(f"{filepath} does not exist.")

      # Load data
      truncations = []
      times = []
      with open(filepath, "r") as f:
          next(f)  # Skip header
          for line in f:
              t, val = line.strip().split(",")
              truncations.append(int(t))
              times.append(float(val))

      # Convert to numpy
      truncations = np.array(truncations)
      times = np.array(times)

      # Plot
      plt.figure(figsize=(8, 5))
      plt.plot(truncations, times, marker="o", linestyle="-", color="lightpink", label="Avg Time (s)")

      plt.xlabel("Truncation")
      plt.ylabel("Time (s)")
      plt.title(filename)
      plt.xticks([trunc_start, trunc_end])
      plt.grid(True)
      plt.legend()
      plt.tight_layout()
      plt.show()
#     MEASURE TVD---------------------------------------------------------------
  def measure_tvd_varying_truncation(
      self,
      numQubits: int,
      depth: int,
      noise: float,
      trunc_start: int,
      trunc_end: int,
      trunc_step: int,
      output_dir: str = "."
  ) -> None:
      filename = f"MeasuringTVDVaryingTruncation{numQubits}Qubits_{depth}Depth_{noise}Noise"
      filepath = os.path.join(output_dir, filename)

      with open(filepath, "w") as f:
          f.write("truncation,average_tvd\n")

          for truncation in range(trunc_start, trunc_end + 1, trunc_step):
              tvds = []
              for _ in range(5):  # average over 5 samples
                  C = circuit_utils.random_circuit(numQubits, depth)
                  gates = circuit_utils.extract_gates_info(C)

                  gate_pos = []
                  for g in gates:
                      layer = g[2]
                      while len(gate_pos) <= layer:
                          gate_pos.append([])
                      a, b = g[1]
                      gate_pos[layer].append((numQubits - a - 1, numQubits - b - 1))

                  circuit = CircuitSim(numQubits, truncation, gate_pos)
                  warnings.filterwarnings("ignore", category=DeprecationWarning)
                  probDist = ProbDist(circuit, gates, numQubits, depth, C, noise)

                  tvds.append(probDist.tvd)

              avg_tvd = sum(tvds) / len(tvds)
              f.write(f"{truncation},{avg_tvd}\n")

  def plot_tvd_varying_truncation(
      self,
      numQubits: int,
      depth: int,
      noise: float,
      trunc_start: int,
      trunc_end: int,
      trunc_step: int,
      output_dir: str = "."
  ) -> None:
      filename = f"MeasuringTVDVaryingTruncation{numQubits}Qubits_{depth}Depth_{noise}Noise"
      filepath = os.path.join(output_dir, filename)

      if not os.path.exists(filepath):
          raise FileNotFoundError(f"{filepath} does not exist.")

      truncations = []
      tvds = []

      with open(filepath, "r") as f:
          next(f)  # skip header
          for line in f:
              t, val = line.strip().split(",")
              truncations.append(int(t))
              tvds.append(float(val))

      truncations = np.array(truncations)
      tvds = np.array(tvds)

      plt.figure(figsize=(8, 5))
      plt.plot(truncations, tvds, marker="o", linestyle="-", color="crimson", label="Avg TVD")

      plt.xlabel("Truncation")
      plt.ylabel("Total Variation Distance")
      plt.title(filename)
      plt.xticks([trunc_start, trunc_end])
      plt.grid(True)
      plt.legend()
      plt.tight_layout()
      plt.show()


    
  def test_time_with_different_truncations(self):
    numQubits = 4 
    depth = 2
    noise = 0.0
    trunc_start = (depth+1)*numQubits
    trunc_end = (depth+1)*numQubits + 5
    trunc_step = 1
    output_dir = "results"

# Uncomment these to actually get some results
    # self.measure_time_varying_truncation(numQubits,depth,noise, trunc_start, trunc_end, trunc_step, output_dir)
    # self.plot_time_varying_truncation(numQubits,depth,noise, trunc_start, trunc_end, trunc_step, output_dir)

    return
  
  def test_TVD_with_different_truncations(self):
    numQubits = 4
    depth = 2
    noise = 0.0
    trunc_start = (depth + 1) * numQubits
    trunc_end = trunc_start + 5
    trunc_step = 1
    output_dir = "results"
    
# Uncomment these to actually get some results
    # self.measure_tvd_varying_truncation(numQubits, depth, noise, trunc_start, trunc_end, trunc_step, output_dir)
    # self.plot_tvd_varying_truncation(numQubits, depth, noise, trunc_start, trunc_end, trunc_step, output_dir)

if __name__ == '__main__':
  unittest.main()